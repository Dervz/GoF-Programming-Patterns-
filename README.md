# GoF-Programming-Patterns-
Gang of Four Programming Patters Java



# Abstract Factory
Предположим, необходимо создать каркас пользовательского интерфейса, который должен работать со многими оконными системами, например, MS Windows, Моtifили MacOS, т.е. на любой платформе с сохранением свойственного платформе внешнего вида и стиля (look and feel). Для каждого типа элемента окна (текстовое поле, кнопка, список и т.д.) создают абстрактный класс, а затем объявляют конкретный подкласс каждого такого класса для каждой поддерживаемой платформы. В целях надежности нужно гарантировать, что все созданные объекты элементов окна предназначены для нужной платформы. Здесь вступают в игру абстрактные классы-фабрики. Абстрактный класс-фабрика определяет методы для создания экземпляра каждого абстрактного класса, представляющего элемент окна пользовательского интерфейса. Конкретные классы-фабрики представляют собой конкретные подклассы абстрактного класса-фабрики, реализующего методы для создания экземпляров конкретных классов элементов окна ДIlЯ одной и той же платформы. С точки зрения общего контекста абстрактный класс-фабрика и его конкретные подклассы организуют набор конкретных классов, работающих с разными, Но связанными продуктами. Предположим, пишется программа, которая выполняет удаленную диагностику компьютеров, произведенных фирмой Stellar Microsystems. Их самые старые компьютеры использовали чипы процессоров фирмы Enginola, имеющие траДиционный набор комплексных команд. С тех пор фирма разработала несколько поколений компьютеров, базирующихся на собственных архитектурах RISC с названиями еmЬег, superember и ultraember. Основные компоненты, используемые в этих моделях, выполняют те же функции, но включают различные наборы деталей. 

Чтобы создаваемая программа знала, какие тесты запускать и как интерпретировать результаты, надо инстанциировать объекты, которые будут соответствовать каждому основному компоненту диагностируемого компьютера. Класс каждого объекта будет соответствовать типу тестируемого компонента. Это означает, что будет набор классов для каждого варианта архитектуры компьютера. В каждом наборе будет класс ДЛЯ компонента компьютера одного и того же типа. На рис. 5.6 представлена диаграмма классов, описывающая организацию классов, в которых инкапсулирована диагностика для компонентов различных видов. Здесь представлены только компоненты двух видов. Структура классов компонента любого другого вида будет аналогичной. Для компонента каждого типа существует интерфейс. Каждая поддерживаемая архитектура компьютера имеет класс, который реализует каждый интерфейс. 
